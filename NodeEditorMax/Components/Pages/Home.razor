@page "/"
@using NodeEditor.Blazor.Components
@using NodeEditor.Blazor.Models
@using NodeEditor.Blazor.Services
@using NodeEditor.Blazor.ViewModels
@using NodeEditor.Blazor.Services.Execution
@using NodeEditorMax.Services
@inject NodeEditorState EditorState
@inject NodeExecutionService ExecutionService
@inject GraphLibraryService GraphLibrary

<div class="node-editor-toolbar">
    <div class="execution-controls">
        <button @onclick="StartExecutionAsync" disabled="@_isExecuting">Start</button>
        <button @onclick="StopExecution" disabled="@(!_isExecuting)">Stop</button>
        <span class="execution-status">@_executionStatus</span>
        @if (!string.IsNullOrWhiteSpace(_lastMessage))
        {
            <span class="execution-message">@_lastMessage</span>
        }
    </div>

    <div class="graph-settings">
        <label class="graph-settings-label">Graph</label>
        <select @bind="_selectedGraphName">
            @foreach (var item in GraphLibrary.Items)
            {
                <option value="@item.Name">@item.Name</option>
            }
        </select>
        <button @onclick="LoadSelectedGraphAsync" disabled="@(!_canLoadGraph)">Load</button>

        <input placeholder="Save as..." @bind="_newGraphName" />
        <button @onclick="SaveCurrentGraphAsync" disabled="@(!_canSaveGraph)">Save</button>

        @if (!string.IsNullOrWhiteSpace(_graphStatus))
        {
            <span class="graph-status">@_graphStatus</span>
        }
    </div>
</div>

<NodePropertiesPanel State="EditorState" />

<div class="node-editor-container">
    <ErrorBoundary>
        <ChildContent>
            <NodeEditorCanvas State="EditorState" />
        </ChildContent>
        <ErrorContent Context="error">
            <div class="error-panel">
                <h3>⚠️ Editor Error</h3>
                <p class="error-message">@error.Message</p>
                <details class="error-details">
                    <summary>Stack Trace</summary>
                    <pre>@error.ToString()</pre>
                </details>
                <button class="btn-recover" @onclick="RecoverFromError">Reload Editor</button>
            </div>
        </ErrorContent>
    </ErrorBoundary>
</div>

@code {
    private CancellationTokenSource? _executionCts;
    private bool _isExecuting;
    private string _executionStatus = "Idle";
    private string? _lastMessage;
    private readonly SampleNodeContext _nodeContext = new();
    private string? _selectedGraphName;
    private string? _newGraphName = "My Graph";
    private string? _graphStatus;
    private bool _isLoadingGraph;

    private bool _canLoadGraph =>
        !_isExecuting && !_isLoadingGraph && !string.IsNullOrWhiteSpace(_selectedGraphName);

    private bool _canSaveGraph =>
        !_isExecuting && !string.IsNullOrWhiteSpace(_newGraphName);

    protected override async Task OnInitializedAsync()
    {
        await GraphLibrary.InitializeAsync();

        if (GraphLibrary.Items.Count > 0)
        {
            _selectedGraphName ??= GraphLibrary.Items[0].Name;
        }

        if (EditorState.Nodes.Count == 0 && _selectedGraphName is not null)
        {
            await LoadSelectedGraphAsync();
        }
    }

    private async Task StartExecutionAsync()
    {
        if (_isExecuting)
        {
            return;
        }

        _isExecuting = true;
        _executionStatus = "Running";
        _lastMessage = null;
        _nodeContext.Reset();

        _executionCts?.Dispose();
        _executionCts = new CancellationTokenSource();

        var context = new NodeExecutionContext();

        try
        {
            await ExecutionService.ExecuteAsync(
                EditorState.Nodes.Select(n => n.Data).ToList(),
                EditorState.Connections.ToList(),
                context,
                _nodeContext,
                null,
                _executionCts.Token).ConfigureAwait(false);

            _executionStatus = "Completed";
        }
        catch (OperationCanceledException)
        {
            _executionStatus = "Canceled";
        }
        catch (Exception ex)
        {
            _executionStatus = $"Failed: {ex.Message}";
        }
        finally
        {
            _isExecuting = false;
            _lastMessage = _nodeContext.LastMessage;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void StopExecution()
    {
        if (!_isExecuting)
        {
            return;
        }

        _executionStatus = "Canceling";
        _executionCts?.Cancel();
    }

    private async Task LoadSelectedGraphAsync()
    {
        if (string.IsNullOrWhiteSpace(_selectedGraphName))
        {
            _graphStatus = "Select a graph to load.";
            return;
        }

        _isLoadingGraph = true;
        _graphStatus = null;

        try
        {
            var result = await GraphLibrary.LoadGraphAsync(_selectedGraphName, EditorState);
            if (result.Warnings.Count > 0)
            {
                _graphStatus = string.Join(" ", result.Warnings);
            }
            else
            {
                _graphStatus = $"Loaded '{_selectedGraphName}'.";
            }
        }
        catch (Exception ex)
        {
            _graphStatus = ex.Message;
        }
        finally
        {
            _isLoadingGraph = false;
        }
    }

    private async Task SaveCurrentGraphAsync()
    {
        var name = _newGraphName?.Trim();
        if (string.IsNullOrWhiteSpace(name))
        {
            _graphStatus = "Enter a name to save.";
            return;
        }

        _graphStatus = null;

        try
        {
            await GraphLibrary.SaveGraphAsync(name, EditorState);
            _selectedGraphName = name;
            _graphStatus = $"Saved '{name}'.";
        }
        catch (Exception ex)
        {
            _graphStatus = ex.Message;
        }
    }

    private void RecoverFromError()
    {
        // Reset editor state to recover from error
        EditorState.Clear();
        StateHasChanged();
    }

    private sealed class SampleNodeContext : INodeMethodContext
    {
        public NodeData? CurrentProcessingNode { get; set; }

        public event Action<string, NodeData, ExecutionFeedbackType, object?, bool>? FeedbackInfo;

        public string? LastMessage { get; private set; }

        public void Reset()
        {
            LastMessage = null;
        }

        [Node("Start", isCallable: true, isExecutionInitiator: true)]
        public void Start(out ExecutionPath ExecOut)
        {
            ExecOut = new ExecutionPath();
            ExecOut.Signal();
        }

        [Node("Add", isCallable: false)]
        public void Add(int A, int B, out int Result)
        {
            Result = A + B;
        }

        [Node("Print", isCallable: true)]
        public void Print(ExecutionPath ExecIn, string Message, out ExecutionPath ExecOut)
        {
            LastMessage = Message;
            ExecOut = new ExecutionPath();
            ExecOut.Signal();
        }

        [Node("Value", isCallable: false)]
        public void ValueNode(int Value, out int Value_Out)
        {
            Value_Out = Value;
        }

        [Node("ToString", isCallable: false)]
        public void ToStringNode(object Input, out string Output)
        {
            Output = Input?.ToString() ?? string.Empty;
        }
    }
}
