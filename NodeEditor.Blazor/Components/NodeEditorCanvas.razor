@using NodeEditor.Blazor.Services
@implements IDisposable
@inject CoordinateConverter CoordinateConverter
@inject ConnectionValidator ConnectionValidator

<div class="ne-canvas"
     @ref="_canvasRef"
     @onpointerdown="OnPointerDown"
     @onpointermove="OnPointerMove"
     @onpointerup="OnPointerUp"
     @onwheel="OnWheel"
     @onwheel:preventDefault
     @onkeydown="OnKeyDown"
     @oncontextmenu="OnContextMenu"
     @oncontextmenu:preventDefault
     tabindex="0">
    @if (_isSelecting)
    {
        <div class="ne-selection-rect" style="@SelectionRectStyle"></div>
    }
    <ContextMenu IsOpen="_isContextMenuOpen"
                 Position="_contextMenuScreenPosition"
                 OnSelect="AddNodeFromDefinition"
                 OnClose="CloseContextMenu" />
    <div class="ne-viewport" style="@ViewportTransformStyle">
        @* Connection layer (SVG) - rendered below nodes *@
        <svg class="ne-connections" @ref="_svgRef">
            @foreach (var connection in State.Connections)
            {
                <ConnectionPath Connection="connection"
                                Nodes="State.Nodes"
                                @key="@GetConnectionKey(connection)" />
            }
            @if (_pendingConnection is not null)
            {
                <ConnectionPath Connection="_pendingConnection"
                                Nodes="State.Nodes"
                                IsPending="true"
                                PendingEndPoint="_pendingConnectionEndGraph" />
            }
        </svg>

        @* Node layer (HTML) - rendered above connections *@
        <div class="ne-nodes">
            @foreach (var node in State.Nodes)
            {
                <NodeComponent Node="node"
                               @key="node.Data.Id"
                               OnSocketPointerDown="OnSocketPointerDown"
                               OnSocketPointerUp="OnSocketPointerUp"
                               OnNodeDragStart="OnNodeDragStart" />
            }
        </div>
    </div>
</div>

@code {
    private ElementReference _canvasRef;
    private ElementReference _svgRef;

    private bool _isPanning;
    private Point2D _panStart;
    private Point2D _panOffset = Point2D.Zero;
    private double _zoom = 1.0;

    private ConnectionData? _pendingConnection;
    private Point2D? _pendingConnectionEndGraph;
    private bool _isDraggingNode;
    private Point2D _dragStart;
    private NodeViewModel? _draggingNode;

    private bool _isSelecting;
    private bool _selectionAdditive;
    private Point2D _selectionStartScreen;
    private Point2D _selectionCurrentScreen;
    private HashSet<string> _selectionBase = new();

    private bool _isContextMenuOpen;
    private Point2D _contextMenuScreenPosition = Point2D.Zero;
    private Point2D _contextMenuGraphPosition = Point2D.Zero;

    [Parameter, EditorRequired]
    public NodeEditorState State { get; set; } = null!;

    [Parameter]
    public double MinZoom { get; set; } = 0.1;

    [Parameter]
    public double MaxZoom { get; set; } = 3.0;

    [Parameter]
    public double ZoomStep { get; set; } = 0.1;

    private string ViewportTransformStyle =>
        $"transform: translate({_panOffset.X}px, {_panOffset.Y}px) scale({_zoom});";

    private string SelectionRectStyle
    {
        get
        {
            var left = Math.Min(_selectionStartScreen.X, _selectionCurrentScreen.X);
            var top = Math.Min(_selectionStartScreen.Y, _selectionCurrentScreen.Y);
            var width = Math.Abs(_selectionCurrentScreen.X - _selectionStartScreen.X);
            var height = Math.Abs(_selectionCurrentScreen.Y - _selectionStartScreen.Y);
            return $"left: {left}px; top: {top}px; width: {width}px; height: {height}px;";
        }
    }

    protected override void OnInitialized()
    {
        CoordinateConverter.SyncFromState(State);

        // Subscribe to state events for reactive updates
        State.NodeAdded += OnStateChanged;
        State.NodeRemoved += OnStateChanged;
        State.ConnectionAdded += OnStateChanged;
        State.ConnectionRemoved += OnStateChanged;
        State.SelectionChanged += OnStateChanged;
        State.ZoomChanged += OnZoomChanged;
        State.ViewportChanged += OnViewportChanged;
    }

    public void Dispose()
    {
        State.NodeAdded -= OnStateChanged;
        State.NodeRemoved -= OnStateChanged;
        State.ConnectionAdded -= OnStateChanged;
        State.ConnectionRemoved -= OnStateChanged;
        State.SelectionChanged -= OnStateChanged;
        State.ZoomChanged -= OnZoomChanged;
        State.ViewportChanged -= OnViewportChanged;
    }

    private void OnStateChanged(object? sender, EventArgs e) => StateHasChanged();
    
    private void OnZoomChanged(object? sender, ZoomChangedEventArgs e)
    {
        _zoom = e.CurrentZoom;
        CoordinateConverter.SyncFromState(State);
        StateHasChanged();
    }

    private void OnViewportChanged(object? sender, ViewportChangedEventArgs e)
    {
        _panOffset = new Point2D(e.CurrentViewport.X, e.CurrentViewport.Y);
        CoordinateConverter.SyncFromState(State);
        StateHasChanged();
    }

    private async Task OnPointerDown(PointerEventArgs e)
    {
        await _canvasRef.FocusAsync();

        if (_isContextMenuOpen && e.Button == 0)
        {
            CloseContextMenu();
        }

        if (e.Button == 1) // Middle mouse button for panning
        {
            _isPanning = true;
            _panStart = new Point2D(e.ClientX - _panOffset.X, e.ClientY - _panOffset.Y);
        }
        else if (e.Button == 0) // Left click on empty canvas clears selection
        {
            BeginSelection(e);
        }
    }

    private void OnPointerMove(PointerEventArgs e)
    {
        if (_isPanning)
        {
            _panOffset = new Point2D(e.ClientX - _panStart.X, e.ClientY - _panStart.Y);
            State.Viewport = new Rect2D(_panOffset.X, _panOffset.Y, State.Viewport.Width, State.Viewport.Height);
        }
        else if (_isDraggingNode && _draggingNode is not null)
        {
            var screenDelta = new Point2D(e.ClientX - _dragStart.X, e.ClientY - _dragStart.Y);
            var graphDelta = CoordinateConverter.ScreenDeltaToGraph(screenDelta);

            var selectedNodes = GetSelectedNodesForDrag();
            foreach (var node in selectedNodes)
            {
                node.Position = new Point2D(
                    node.Position.X + graphDelta.X,
                    node.Position.Y + graphDelta.Y);
            }

            _dragStart = new Point2D(e.ClientX, e.ClientY);
            StateHasChanged();
        }
        else if (_pendingConnection is not null)
        {
            _pendingConnectionEndGraph = CoordinateConverter.ScreenToGraph(new Point2D(e.ClientX, e.ClientY));
            StateHasChanged();
        }
        else if (_isSelecting)
        {
            _selectionCurrentScreen = new Point2D(e.ClientX, e.ClientY);
            UpdateSelectionFromRect();
        }
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        _isPanning = false;
        _isDraggingNode = false;
        _draggingNode = null;
        _pendingConnection = null;
        _pendingConnectionEndGraph = null;

        if (_isSelecting)
        {
            _selectionCurrentScreen = new Point2D(e.ClientX, e.ClientY);
            UpdateSelectionFromRect(finalize: true);
            _isSelecting = false;
        }
    }

    private void OnWheel(WheelEventArgs e)
    {
        var zoomDelta = e.DeltaY > 0 ? -ZoomStep : ZoomStep;
        var newZoom = Math.Clamp(_zoom + zoomDelta, MinZoom, MaxZoom);
        
        if (Math.Abs(newZoom - _zoom) > double.Epsilon)
        {
            var focus = new Point2D(e.ClientX, e.ClientY);
            var newPan = CoordinateConverter.ComputeZoomCenteredPan(focus, _zoom, newZoom);
            State.Zoom = newZoom;
            State.Viewport = new Rect2D(newPan.X, newPan.Y, State.Viewport.Width, State.Viewport.Height);
        }
    }

    private void OnContextMenu(MouseEventArgs e)
    {
        _contextMenuScreenPosition = new Point2D(e.ClientX, e.ClientY);
        _contextMenuGraphPosition = CoordinateConverter.ScreenToGraph(_contextMenuScreenPosition);
        _isContextMenuOpen = true;
        StateHasChanged();
    }

    private void OnSocketPointerDown(SocketPointerEventArgs e)
    {
        // Start creating a connection from this socket
        if (!e.Socket.Data.IsInput)
        {
            _pendingConnection = new ConnectionData(
                OutputNodeId: e.NodeId,
                InputNodeId: string.Empty,
                OutputSocketName: e.Socket.Data.Name,
                InputSocketName: string.Empty,
                IsExecution: e.Socket.Data.IsExecution);
            _pendingConnectionEndGraph = CoordinateConverter.ScreenToGraph(e.Position);
        }
    }

    private void OnSocketPointerUp(SocketPointerEventArgs e)
    {
        // Complete the connection if we have a pending one
        if (_pendingConnection is not null && e.Socket.Data.IsInput)
        {
            var connection = _pendingConnection with
            {
                InputNodeId = e.NodeId,
                InputSocketName = e.Socket.Data.Name
            };
            
            // Validate connection is not to the same node
            if (connection.OutputNodeId != connection.InputNodeId)
            {
                if (IsValidConnection(connection, e.Socket))
                {
                    State.AddConnection(connection);
                }
            }
        }
        _pendingConnection = null;
        _pendingConnectionEndGraph = null;
    }

    private void OnNodeDragStart(NodePointerEventArgs e)
    {
        var node = State.Nodes.FirstOrDefault(n => n.Data.Id == e.NodeId);
        if (node is null)
        {
            return;
        }

        _isSelecting = false;
        _isDraggingNode = true;
        _draggingNode = node;
        _dragStart = e.Position;

        if (!node.IsSelected)
        {
            State.SelectNode(node.Data.Id, clearExisting: true);
        }
    }

    private void BeginSelection(PointerEventArgs e)
    {
        _isSelecting = true;
        _selectionStartScreen = new Point2D(e.ClientX, e.ClientY);
        _selectionCurrentScreen = _selectionStartScreen;
        _selectionAdditive = e.CtrlKey || e.ShiftKey;
        _selectionBase = _selectionAdditive ? State.SelectedNodeIds.ToHashSet() : new HashSet<string>();

        if (!_selectionAdditive)
        {
            State.ClearSelection();
        }
    }

    private void UpdateSelectionFromRect(bool finalize = false)
    {
        var selectionRectGraph = GetSelectionRectGraph();
        var selected = State.Nodes
            .Where(n => RectsIntersect(selectionRectGraph, new Rect2D(n.Position.X, n.Position.Y, n.Size.Width, n.Size.Height)))
            .Select(n => n.Data.Id)
            .ToHashSet();

        if (_selectionAdditive)
        {
            selected.UnionWith(_selectionBase);
        }

        State.SelectNodes(selected, clearExisting: true);

        if (finalize)
        {
            _selectionBase = selected;
        }
    }

    private Rect2D GetSelectionRectGraph()
    {
        var left = Math.Min(_selectionStartScreen.X, _selectionCurrentScreen.X);
        var top = Math.Min(_selectionStartScreen.Y, _selectionCurrentScreen.Y);
        var width = Math.Abs(_selectionCurrentScreen.X - _selectionStartScreen.X);
        var height = Math.Abs(_selectionCurrentScreen.Y - _selectionStartScreen.Y);

        var screenRect = new Rect2D(left, top, width, height);
        return CoordinateConverter.ScreenToGraph(screenRect);
    }

    private static bool RectsIntersect(Rect2D a, Rect2D b)
    {
        return a.X <= b.X + b.Width &&
               a.X + a.Width >= b.X &&
               a.Y <= b.Y + b.Height &&
               a.Y + a.Height >= b.Y;
    }

    private IEnumerable<NodeViewModel> GetSelectedNodesForDrag()
    {
        if (_draggingNode is null)
        {
            return Array.Empty<NodeViewModel>();
        }

        if (_draggingNode.IsSelected)
        {
            return State.Nodes.Where(n => n.IsSelected);
        }

        return new[] { _draggingNode };
    }

    private bool IsValidConnection(ConnectionData connection, SocketViewModel targetSocket)
    {
        if (State.Connections.Any(c =>
            c.InputNodeId == connection.InputNodeId &&
            c.InputSocketName == connection.InputSocketName))
        {
            return false;
        }

        var sourceNode = State.Nodes.FirstOrDefault(n => n.Data.Id == connection.OutputNodeId);
        var sourceSocket = sourceNode?.Outputs.FirstOrDefault(s => s.Data.Name == connection.OutputSocketName);

        if (sourceSocket is null)
        {
            return false;
        }

        return ConnectionValidator.CanConnect(sourceSocket.Data, targetSocket.Data);
    }

    private void CancelInteraction()
    {
        _isPanning = false;
        _isDraggingNode = false;
        _draggingNode = null;
        _pendingConnection = null;
        _pendingConnectionEndGraph = null;
        _isSelecting = false;
        CloseContextMenu();
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key is "Delete" or "Backspace")
        {
            State.RemoveSelectedNodes();
        }
        else if (e.Key == "Escape")
        {
            CancelInteraction();
        }
        else if (e.CtrlKey && (e.Key == "a" || e.Key == "A"))
        {
            State.SelectAll();
        }
        else if (e.CtrlKey && (e.Key == "z" || e.Key == "Z"))
        {
            State.RequestUndo();
        }
        else if (e.CtrlKey && (e.Key == "y" || e.Key == "Y"))
        {
            State.RequestRedo();
        }
    }

    private void AddNodeFromDefinition(NodeDefinition definition)
    {
        var nodeData = definition.Factory();
        var nodeViewModel = new NodeViewModel(nodeData)
        {
            Position = _contextMenuGraphPosition
        };

        State.AddNode(nodeViewModel);
    }

    private void CloseContextMenu()
    {
        _isContextMenuOpen = false;
    }

    private static string GetConnectionKey(ConnectionData c) =>
        $"{c.OutputNodeId}:{c.OutputSocketName}->{c.InputNodeId}:{c.InputSocketName}";
}
