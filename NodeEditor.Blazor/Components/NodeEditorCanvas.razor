@using NodeEditor.Blazor.Services
@implements IDisposable
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject CoordinateConverter CoordinateConverter
@inject ConnectionValidator ConnectionValidator
@inject TouchGestureHandler TouchGestures
@inject ViewportCuller ViewportCuller

<div class="ne-canvas"
     @ref="_canvasRef"
     @onpointerdown="OnPointerDown"
     @onpointermove="OnPointerMove"
     @onpointerup="OnPointerUp"
     @onwheel="OnWheel"
     @onwheel:preventDefault
     @onkeydown="OnKeyDown"
     @oncontextmenu="OnContextMenu"
     @oncontextmenu:preventDefault
     @ontouchstart="OnTouchStart"
     @ontouchmove="OnTouchMove"
     @ontouchend="OnTouchEnd"
     @ontouchcancel="OnTouchCancel"
     tabindex="0">
    @if (_isSelecting)
    {
        <div class="ne-selection-rect" style="@SelectionRectStyle"></div>
    }
    <ContextMenu IsOpen="_isContextMenuOpen"
                 Position="_contextMenuScreenPosition"
                 OnSelect="AddNodeFromDefinition"
                 OnClose="CloseContextMenu" />
    <div class="ne-viewport" style="@ViewportTransformStyle">
        @* Connection layer (SVG) - rendered below nodes *@
        <svg class="ne-connections" @ref="_svgRef">
            @foreach (var connection in _visibleConnections)
            {
                <ConnectionPath Connection="connection"
                                Nodes="State.Nodes"
                                IsSelected="State.SelectedConnection == connection"
                                OnSelected="OnConnectionSelected"
                                @key="@GetConnectionKey(connection)" />
            }
            @if (_pendingConnection is not null)
            {
                <ConnectionPath Connection="_pendingConnection"
                                Nodes="State.Nodes"
                                IsPending="true"
                                PendingEndPoint="_pendingConnectionEndGraph" />
            }
        </svg>

        @* Node layer (HTML) - rendered above connections *@
        <CascadingValue Value="State">
            <div class="ne-nodes">
                @foreach (var node in _visibleNodes)
                {
                    <NodeComponent Node="node"
                                   Connections="State.Connections"
                                   @key="node.Data.Id"
                                   OnSocketPointerDown="OnSocketPointerDown"
                                   OnSocketPointerUp="OnSocketPointerUp"
                                   OnNodeDragStart="OnNodeDragStart" />
                }
            </div>
        </CascadingValue>
    </div>
</div>

@code {
    private ElementReference _canvasRef;
    private ElementReference _svgRef;

    private bool _isPanning;
    private Point2D _panStart;
    private Point2D _panOffset = Point2D.Zero;
    private double _zoom = 1.0;

    private ConnectionData? _pendingConnection;
    private Point2D? _pendingConnectionEndGraph;
    private bool _isDraggingNode;
    private Point2D _dragStart;
    private NodeViewModel? _draggingNode;

    private bool _isSelecting;
    private bool _selectionAdditive;
    private Point2D _selectionStartScreen;
    private Point2D _selectionCurrentScreen;
    private HashSet<string> _selectionBase = new();

    private bool _isContextMenuOpen;
    private Point2D _contextMenuScreenPosition = Point2D.Zero;
    private Point2D _contextMenuGraphPosition = Point2D.Zero;

    private bool _isTouchGesture;
    private double _touchZoomBase = 1.0;

    private Point2D _canvasScreenOffset = Point2D.Zero;

    private IReadOnlyList<NodeViewModel> _visibleNodes = Array.Empty<NodeViewModel>();
    private IReadOnlyList<ConnectionData> _visibleConnections = Array.Empty<ConnectionData>();

    private readonly Dictionary<string, Point2D> _socketPositionCache = new();

    [Parameter, EditorRequired]
    public NodeEditorState State { get; set; } = null!;

    [Parameter]
    public double MinZoom { get; set; } = 0.1;

    [Parameter]
    public double MaxZoom { get; set; } = 3.0;

    [Parameter]
    public double ZoomStep { get; set; } = 0.1;

    private string ViewportTransformStyle =>
        $"transform: translate({_panOffset.X}px, {_panOffset.Y}px) scale({_zoom});";

    private string SelectionRectStyle
    {
        get
        {
            var left = Math.Min(_selectionStartScreen.X, _selectionCurrentScreen.X);
            var top = Math.Min(_selectionStartScreen.Y, _selectionCurrentScreen.Y);
            var width = Math.Abs(_selectionCurrentScreen.X - _selectionStartScreen.X);
            var height = Math.Abs(_selectionCurrentScreen.Y - _selectionStartScreen.Y);
            return $"left: {left}px; top: {top}px; width: {width}px; height: {height}px;";
        }
    }

    protected override void OnInitialized()
    {
        CoordinateConverter.SyncFromState(State);

        // Subscribe to state events for reactive updates
        State.NodeAdded += OnStateChanged;
        State.NodeRemoved += OnStateChanged;
        State.ConnectionAdded += OnStateChanged;
        State.ConnectionRemoved += OnStateChanged;
        State.SelectionChanged += OnStateChanged;
        State.ConnectionSelectionChanged += OnStateChanged;
        State.NodeExecutionStateChanged += OnStateChanged;
        State.SocketValuesChanged += OnStateChanged;
        State.ZoomChanged += OnZoomChanged;
        State.ViewportChanged += OnViewportChanged;

        UpdateCulling();
    }

    private async Task UpdateCanvasScreenOffsetAsync()
    {
        if (_canvasJsModule is null)
        {
            return;
        }

        _canvasScreenOffset = await _canvasJsModule.InvokeAsync<Point2D>("getCanvasScreenOffset", _canvasRef);
    }

    private Point2D ToCanvasPoint(Point2D clientPoint) =>
        new(clientPoint.X - _canvasScreenOffset.X, clientPoint.Y - _canvasScreenOffset.Y);

    public void Dispose()
    {
        State.NodeAdded -= OnStateChanged;
        State.NodeRemoved -= OnStateChanged;
        State.ConnectionAdded -= OnStateChanged;
        State.ConnectionRemoved -= OnStateChanged;
        State.SelectionChanged -= OnStateChanged;
        State.ConnectionSelectionChanged -= OnStateChanged;
        State.NodeExecutionStateChanged -= OnStateChanged;
        State.SocketValuesChanged -= OnStateChanged;
        State.ZoomChanged -= OnZoomChanged;
        State.ViewportChanged -= OnViewportChanged;
    }

    private void OnStateChanged(object? sender, EventArgs e)
    {
        UpdateCulling();
        StateHasChanged();
    }
    
    private void OnZoomChanged(object? sender, ZoomChangedEventArgs e)
    {
        _zoom = e.CurrentZoom;
        CoordinateConverter.SyncFromState(State);
        UpdateCulling();
        StateHasChanged();
    }

    private void OnViewportChanged(object? sender, ViewportChangedEventArgs e)
    {
        _panOffset = new Point2D(e.CurrentViewport.X, e.CurrentViewport.Y);
        CoordinateConverter.SyncFromState(State);
        UpdateCulling();
        StateHasChanged();
    }

    private async Task OnPointerDown(PointerEventArgs e)
    {
        await _canvasRef.FocusAsync();
        await UpdateCanvasScreenOffsetAsync();

        var canvasPoint = ToCanvasPoint(new Point2D(e.ClientX, e.ClientY));

        if (_isContextMenuOpen && e.Button == 0)
        {
            CloseContextMenu();
        }

        if (e.Button == 1) // Middle mouse button for panning
        {
            _isPanning = true;
            _panStart = new Point2D(canvasPoint.X - _panOffset.X, canvasPoint.Y - _panOffset.Y);
        }
        else if (e.Button == 0) // Left click on empty canvas clears selection
        {
            BeginSelection(e, canvasPoint);
        }
    }

    private void OnPointerMove(PointerEventArgs e)
    {
        var canvasPoint = ToCanvasPoint(new Point2D(e.ClientX, e.ClientY));

        if (_isPanning)
        {
            _panOffset = new Point2D(canvasPoint.X - _panStart.X, canvasPoint.Y - _panStart.Y);
            State.Viewport = new Rect2D(_panOffset.X, _panOffset.Y, State.Viewport.Width, State.Viewport.Height);
            UpdateCulling();
        }
        else if (_isDraggingNode && _draggingNode is not null)
        {
            var screenDelta = new Point2D(canvasPoint.X - _dragStart.X, canvasPoint.Y - _dragStart.Y);
            var graphDelta = CoordinateConverter.ScreenDeltaToGraph(screenDelta);

            var selectedNodes = GetSelectedNodesForDrag();
            foreach (var node in selectedNodes)
            {
                node.Position = new Point2D(
                    node.Position.X + graphDelta.X,
                    node.Position.Y + graphDelta.Y);
            }

            _dragStart = canvasPoint;
            UpdateCulling();
            StateHasChanged();
        }
        else if (_pendingConnection is not null)
        {
            _pendingConnectionEndGraph = CoordinateConverter.ScreenToGraph(canvasPoint);
            StateHasChanged();
        }
        else if (_isSelecting)
        {
            _selectionCurrentScreen = canvasPoint;
            UpdateSelectionFromRect();
        }
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        _isPanning = false;
        _isDraggingNode = false;
        _draggingNode = null;
        _pendingConnection = null;
        _pendingConnectionEndGraph = null;

        if (_isSelecting)
        {
            _selectionCurrentScreen = ToCanvasPoint(new Point2D(e.ClientX, e.ClientY));
            UpdateSelectionFromRect(finalize: true);
            _isSelecting = false;
        }
    }

    private void OnWheel(WheelEventArgs e)
    {
        var zoomDelta = e.DeltaY > 0 ? -ZoomStep : ZoomStep;
        var newZoom = Math.Clamp(_zoom + zoomDelta, MinZoom, MaxZoom);
        
        if (Math.Abs(newZoom - _zoom) > double.Epsilon)
        {
            var focus = ToCanvasPoint(new Point2D(e.ClientX, e.ClientY));
            var newPan = CoordinateConverter.ComputeZoomCenteredPan(focus, _zoom, newZoom);
            State.Zoom = newZoom;
            State.Viewport = new Rect2D(newPan.X, newPan.Y, State.Viewport.Width, State.Viewport.Height);
        }
    }

    private void OnContextMenu(MouseEventArgs e)
    {
        _contextMenuScreenPosition = ToCanvasPoint(new Point2D(e.ClientX, e.ClientY));
        _contextMenuGraphPosition = CoordinateConverter.ScreenToGraph(_contextMenuScreenPosition);
        _isContextMenuOpen = true;
        StateHasChanged();
    }

    private void OnSocketPointerDown(SocketPointerEventArgs e)
    {
        // Start creating a connection from this socket
        if (!e.Socket.Data.IsInput)
        {
            _pendingConnection = new ConnectionData(
                OutputNodeId: e.NodeId,
                InputNodeId: string.Empty,
                OutputSocketName: e.Socket.Data.Name,
                InputSocketName: string.Empty,
                IsExecution: e.Socket.Data.IsExecution);
            var canvasPoint = ToCanvasPoint(e.Position);
            _pendingConnectionEndGraph = CoordinateConverter.ScreenToGraph(canvasPoint);
        }
    }

    private void OnSocketPointerUp(SocketPointerEventArgs e)
    {
        // Complete the connection if we have a pending one
        if (_pendingConnection is not null && e.Socket.Data.IsInput)
        {
            var connection = _pendingConnection with
            {
                InputNodeId = e.NodeId,
                InputSocketName = e.Socket.Data.Name
            };
            
            // Validate connection is not to the same node
            if (connection.OutputNodeId != connection.InputNodeId)
            {
                if (IsValidConnection(connection, e.Socket))
                {
                    State.AddConnection(connection);
                }
            }
        }
        _pendingConnection = null;
        _pendingConnectionEndGraph = null;
    }

    private void OnNodeDragStart(NodePointerEventArgs e)
    {
        var node = State.Nodes.FirstOrDefault(n => n.Data.Id == e.NodeId);
        if (node is null)
        {
            return;
        }

        _isSelecting = false;
        _isDraggingNode = true;
        _draggingNode = node;
        _dragStart = ToCanvasPoint(e.Position);

        if (!node.IsSelected)
        {
            State.SelectNode(node.Data.Id, clearExisting: true);
        }
    }

    private void BeginSelection(PointerEventArgs e, Point2D canvasPoint)
    {
        _isSelecting = true;
        _selectionStartScreen = canvasPoint;
        _selectionCurrentScreen = _selectionStartScreen;
        _selectionAdditive = e.CtrlKey || e.ShiftKey;
        _selectionBase = _selectionAdditive ? State.SelectedNodeIds.ToHashSet() : new HashSet<string>();

        State.ClearConnectionSelection();

        if (!_selectionAdditive)
        {
            State.ClearSelection();
        }
    }

    private void UpdateSelectionFromRect(bool finalize = false)
    {
        var selectionRectGraph = GetSelectionRectGraph();
        var selected = State.Nodes
            .Where(n => selectionRectGraph.Intersects(new Rect2D(n.Position.X, n.Position.Y, n.Size.Width, n.Size.Height)))
            .Select(n => n.Data.Id)
            .ToHashSet();

        if (_selectionAdditive)
        {
            selected.UnionWith(_selectionBase);
        }

        State.SelectNodes(selected, clearExisting: true);

        if (finalize)
        {
            _selectionBase = selected;
        }
    }

    private Rect2D GetSelectionRectGraph()
    {
        var left = Math.Min(_selectionStartScreen.X, _selectionCurrentScreen.X);
        var top = Math.Min(_selectionStartScreen.Y, _selectionCurrentScreen.Y);
        var width = Math.Abs(_selectionCurrentScreen.X - _selectionStartScreen.X);
        var height = Math.Abs(_selectionCurrentScreen.Y - _selectionStartScreen.Y);

        var screenRect = new Rect2D(left, top, width, height);
        return CoordinateConverter.ScreenToGraph(screenRect);
    }

    private IEnumerable<NodeViewModel> GetSelectedNodesForDrag()
    {
        if (_draggingNode is null)
        {
            return Array.Empty<NodeViewModel>();
        }

        if (_draggingNode.IsSelected)
        {
            return State.Nodes.Where(n => n.IsSelected);
        }

        return new[] { _draggingNode };
    }

    private bool IsValidConnection(ConnectionData connection, SocketViewModel targetSocket)
    {
        if (State.Connections.Any(c =>
            c.InputNodeId == connection.InputNodeId &&
            c.InputSocketName == connection.InputSocketName))
        {
            return false;
        }

        var sourceNode = State.Nodes.FirstOrDefault(n => n.Data.Id == connection.OutputNodeId);
        var sourceSocket = sourceNode?.Outputs.FirstOrDefault(s => s.Data.Name == connection.OutputSocketName);

        if (sourceSocket is null)
        {
            return false;
        }

        return ConnectionValidator.CanConnect(sourceSocket.Data, targetSocket.Data);
    }

    private void CancelInteraction()
    {
        _isPanning = false;
        _isDraggingNode = false;
        _draggingNode = null;
        _pendingConnection = null;
        _pendingConnectionEndGraph = null;
        _isSelecting = false;
        CloseContextMenu();
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key is "Delete" or "Backspace")
        {
            if (State.SelectedConnection is not null)
            {
                State.RemoveConnection(State.SelectedConnection);
            }
            else
            {
                State.RemoveSelectedNodes();
            }
        }
        else if (e.Key == "Escape")
        {
            CancelInteraction();
        }
        else if (e.CtrlKey && (e.Key == "a" || e.Key == "A"))
        {
            State.SelectAll();
        }
        else if (e.CtrlKey && (e.Key == "z" || e.Key == "Z"))
        {
            State.RequestUndo();
        }
        else if (e.CtrlKey && (e.Key == "y" || e.Key == "Y"))
        {
            State.RequestRedo();
        }
    }

    private void AddNodeFromDefinition(NodeDefinition definition)
    {
        var nodeData = definition.Factory();
        var nodeViewModel = new NodeViewModel(nodeData)
        {
            Position = _contextMenuGraphPosition
        };

        State.AddNode(nodeViewModel);
    }

    private void CloseContextMenu()
    {
        _isContextMenuOpen = false;
    }

    // ===== Touch Event Handlers =====

    private void OnTouchStart(TouchEventArgs e)
    {
        _ = UpdateCanvasScreenOffsetAsync();
        _isTouchGesture = true;
        
        var touches = e.ChangedTouches.Select(t =>
        {
            var canvasPoint = ToCanvasPoint(new Point2D(t.ClientX, t.ClientY));
            return new TouchPoint2D(t.Identifier, canvasPoint.X, canvasPoint.Y);
        }).ToList();
        
        var result = TouchGestures.OnTouchStart(touches);
        
        if (result != null)
        {
            switch (result.Type)
            {
                case TouchGestureHandler.TouchGestureType.DragStart:
                    // Check if touch is on a node for dragging
                    var graphPos = CoordinateConverter.ScreenToGraph(result.Position);
                    var nodeAtPosition = FindNodeAtPosition(graphPos);
                    
                    if (nodeAtPosition != null)
                    {
                        _isDraggingNode = true;
                        _draggingNode = nodeAtPosition;
                        _dragStart = graphPos;
                    }
                    else
                    {
                        // Start pan with single touch
                        _isPanning = true;
                        _panStart = result.Position;
                    }
                    break;
            }
        }

        StateHasChanged();
    }

    private void OnTouchMove(TouchEventArgs e)
    {
        if (!_isTouchGesture) return;

        var touches = e.Touches.Select(t =>
        {
            var canvasPoint = ToCanvasPoint(new Point2D(t.ClientX, t.ClientY));
            return new TouchPoint2D(t.Identifier, canvasPoint.X, canvasPoint.Y);
        }).ToList();
        
        var result = TouchGestures.OnTouchMove(touches);
        
        if (result != null)
        {
            switch (result.Type)
            {
                case TouchGestureHandler.TouchGestureType.Pan:
                    if (result.Delta.HasValue)
                    {
                        _panOffset = new Point2D(
                            _panOffset.X + result.Delta.Value.X,
                            _panOffset.Y + result.Delta.Value.Y
                        );
                        CoordinateConverter.PanOffset = _panOffset;
                        State.Viewport = new Rect2D(_panOffset.X, _panOffset.Y, State.Viewport.Width, State.Viewport.Height);
                    }
                    break;

                case TouchGestureHandler.TouchGestureType.Zoom:
                    if (result.ZoomDelta.HasValue && result.ZoomCenter.HasValue)
                    {
                        var newZoom = Math.Clamp(_touchZoomBase * result.ZoomDelta.Value, MinZoom, MaxZoom);
                        
                        // Zoom towards the pinch center
                        var screenCenter = result.ZoomCenter.Value;
                        var graphBefore = CoordinateConverter.ScreenToGraph(screenCenter);
                        
                        _zoom = newZoom;
                        CoordinateConverter.Zoom = _zoom;
                        
                        var graphAfter = CoordinateConverter.ScreenToGraph(screenCenter);
                        var correction = new Point2D(
                            (graphAfter.X - graphBefore.X) * _zoom,
                            (graphAfter.Y - graphBefore.Y) * _zoom
                        );
                        
                        _panOffset = new Point2D(
                            _panOffset.X + correction.X,
                            _panOffset.Y + correction.Y
                        );
                        CoordinateConverter.PanOffset = _panOffset;
                        State.Zoom = _zoom;
                        State.Viewport = new Rect2D(_panOffset.X, _panOffset.Y, State.Viewport.Width, State.Viewport.Height);
                    }
                    break;

                case TouchGestureHandler.TouchGestureType.Drag:
                    if (_isDraggingNode && _draggingNode != null)
                    {
                        var currentPos = CoordinateConverter.ScreenToGraph(result.Position);
                        var delta = new Point2D(
                            currentPos.X - _dragStart.X,
                            currentPos.Y - _dragStart.Y
                        );
                        
                        _draggingNode.Position = new Point2D(
                            _draggingNode.Position.X + delta.X,
                            _draggingNode.Position.Y + delta.Y
                        );
                        
                        _dragStart = currentPos;
                    }
                    else if (_isPanning)
                    {
                        var delta = new Point2D(
                            result.Position.X - _panStart.X,
                            result.Position.Y - _panStart.Y
                        );
                        
                        _panOffset = new Point2D(
                            _panOffset.X + delta.X,
                            _panOffset.Y + delta.Y
                        );
                        CoordinateConverter.PanOffset = _panOffset;
                        
                        _panStart = result.Position;
                        State.Viewport = new Rect2D(_panOffset.X, _panOffset.Y, State.Viewport.Width, State.Viewport.Height);
                    }
                    break;
            }
        }

        UpdateCulling();
        StateHasChanged();
    }

    private void OnTouchEnd(TouchEventArgs e)
    {
        if (!_isTouchGesture) return;

        var remainingTouches = e.Touches.Select(t =>
        {
            var canvasPoint = ToCanvasPoint(new Point2D(t.ClientX, t.ClientY));
            return new TouchPoint2D(t.Identifier, canvasPoint.X, canvasPoint.Y);
        }).ToList();
        
        var result = TouchGestures.OnTouchEnd(remainingTouches);
        
        if (result != null)
        {
            switch (result.Type)
            {
                case TouchGestureHandler.TouchGestureType.Tap:
                    var graphPos = CoordinateConverter.ScreenToGraph(result.Position);
                    var nodeAtPosition = FindNodeAtPosition(graphPos);
                    
                    if (nodeAtPosition != null)
                    {
                        State.SelectNode(nodeAtPosition.Data.Id);
                    }
                    else
                    {
                        State.ClearConnectionSelection();
                        State.ClearSelection();
                    }
                    break;

                case TouchGestureHandler.TouchGestureType.DragEnd:
                    _isDraggingNode = false;
                    _draggingNode = null;
                    _isPanning = false;
                    _touchZoomBase = _zoom;
                    break;
            }
        }

        if (remainingTouches.Count == 0)
        {
            _isTouchGesture = false;
            TouchGestures.Reset();
        }

        StateHasChanged();
    }

    private void OnTouchCancel(TouchEventArgs e)
    {
        _isTouchGesture = false;
        _isDraggingNode = false;
        _draggingNode = null;
        _isPanning = false;
        TouchGestures.Reset();
        StateHasChanged();
    }

    private NodeViewModel? FindNodeAtPosition(Point2D graphPosition)
    {
        // Check nodes in reverse order (top-most first)
        for (int i = State.Nodes.Count - 1; i >= 0; i--)
        {
            var node = State.Nodes[i];
            var nodeRect = new Rect2D(
                node.Position.X,
                node.Position.Y,
                node.Size.Width,
                node.Size.Height
            );

            if (nodeRect.Contains(graphPosition))
            {
                return node;
            }
        }

        return null;
    }

    private void OnConnectionSelected(ConnectionData connection)
    {
        State.SelectConnection(connection);
    }

    private static string GetConnectionKey(ConnectionData c) =>
        $"{c.OutputNodeId}:{c.OutputSocketName}->{c.InputNodeId}:{c.InputSocketName}";

    private void UpdateCulling()
    {
        if (State.Viewport.Width <= 0 || State.Viewport.Height <= 0)
        {
            _visibleNodes = State.Nodes;
            _visibleConnections = State.Connections;
            return;
        }

        const double cullPadding = 800;
        var screenViewport = new Rect2D(
            -cullPadding,
            -cullPadding,
            State.Viewport.Width + cullPadding * 2,
            State.Viewport.Height + cullPadding * 2);
        var alwaysInclude = _isDraggingNode && _draggingNode is not null
            ? new[] { _draggingNode.Data.Id }
            : Array.Empty<string>();

        _visibleNodes = ViewportCuller.GetVisibleNodes(State.Nodes, screenViewport, alwaysInclude);
        _visibleConnections = ViewportCuller.GetVisibleConnections(State.Connections, _visibleNodes, alwaysInclude);
    }
}
