@page "/"
@implements IDisposable
@rendermode InteractiveServer
@using NodeEditor.Blazor.Components
@using NodeEditor.Blazor.Models
@using NodeEditor.Blazor.Services
@using NodeEditor.Blazor.Services.Registry
@using NodeEditor.Blazor.ViewModels
@using NodeEditor.Blazor.Services.Execution
@inject NodeEditorState EditorState
@inject NodeExecutionService ExecutionService
@inject NodeRegistryService Registry

<PageTitle>Node Editor</PageTitle>

<div class="node-editor-toolbar">
	<button @onclick="StartExecutionAsync" disabled="@_isExecuting">Start</button>
	<button @onclick="StopExecution" disabled="@(!_isExecuting)">Stop</button>
	<span class="execution-status">@_executionStatus</span>
</div>

<NodePropertiesPanel State="EditorState" />

<div class="node-editor-container">
	<NodeEditorCanvas State="EditorState" />
</div>

@code {
	private CancellationTokenSource? _executionCts;
	private bool _isExecuting;
	private string _executionStatus = "Idle";
	private readonly StandardNodeContext _nodeContext = new();

	protected override void OnInitialized()
	{
		Registry.RegisterFromAssembly(typeof(StandardNodeContext).Assembly);

		if (EditorState.Nodes.Count == 0)
		{
			CreateSampleGraph();
		}

		ExecutionService.NodeStarted += OnNodeStarted;
		ExecutionService.NodeCompleted += OnNodeCompleted;
		ExecutionService.NodeFailed += OnNodeFailed;
	}

	public void Dispose()
	{
		ExecutionService.NodeStarted -= OnNodeStarted;
		ExecutionService.NodeCompleted -= OnNodeCompleted;
		ExecutionService.NodeFailed -= OnNodeFailed;
	}

	private async Task StartExecutionAsync()
	{
		if (_isExecuting)
		{
			return;
		}

		_isExecuting = true;
		_executionStatus = "Running";
		EditorState.ResetNodeExecutionState();

		_executionCts?.Dispose();
		_executionCts = new CancellationTokenSource();

		var context = new NodeExecutionContext();
		var executionNodes = EditorState.BuildExecutionNodes();

		try
		{
			await ExecutionService.ExecuteAsync(
				executionNodes,
				EditorState.Connections.ToList(),
				context,
				_nodeContext,
				null,
				_executionCts.Token).ConfigureAwait(false);

			EditorState.ApplyExecutionContext(context);

			_executionStatus = "Completed";
		}
		catch (OperationCanceledException)
		{
			_executionStatus = "Canceled";
		}
		catch (Exception ex)
		{
			_executionStatus = $"Failed: {ex.Message}";
		}
		finally
		{
			_isExecuting = false;
			await InvokeAsync(StateHasChanged);
		}
	}

	private void OnNodeStarted(object? sender, NodeExecutionEventArgs e)
	{
		_ = InvokeAsync(() =>
		{
			EditorState.SetNodeExecuting(e.Node.Id, true);
			EditorState.SetNodeError(e.Node.Id, false);
		});
	}

	private void OnNodeCompleted(object? sender, NodeExecutionEventArgs e)
	{
		_ = InvokeAsync(() =>
		{
			EditorState.SetNodeExecuting(e.Node.Id, false);
		});
	}

	private void OnNodeFailed(object? sender, NodeExecutionFailedEventArgs e)
	{
		_ = InvokeAsync(() =>
		{
			EditorState.SetNodeExecuting(e.Node.Id, false);
			EditorState.SetNodeError(e.Node.Id, true);
		});
	}

	private void StopExecution()
	{
		if (!_isExecuting)
		{
			return;
		}

		_executionStatus = "Canceling";
		_executionCts?.Cancel();
	}

	private void CreateSampleGraph()
	{
		var execType = typeof(ExecutionPath).FullName ?? "ExecutionPath";
		var listType = typeof(SerializableList).FullName ?? "SerializableList";
		var intType = typeof(int).FullName ?? "System.Int32";
		var stringType = typeof(string).FullName ?? "System.String";
		var doubleType = typeof(double).FullName ?? "System.Double";

		var startLoop = new NodeViewModel(new NodeData(
			Id: "start-loop",
			Name: "Start",
			Callable: true,
			ExecInit: true,
			Inputs: Array.Empty<SocketData>(),
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(60, 80)
		};

		var forLoop = new NodeViewModel(new NodeData(
			Id: "for-loop",
			Name: "For Loop Step",
			Callable: true,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("Enter", execType, true, true),
				new SocketData("StartValue", intType, true, false, SocketValue.FromObject(0)),
				new SocketData("EndValue", intType, true, false, SocketValue.FromObject(4)),
				new SocketData("Step", intType, true, false, SocketValue.FromObject(1))
			},
			Outputs: new[]
			{
				new SocketData("ExitPath", execType, false, true),
				new SocketData("LoopPath", execType, false, true),
				new SocketData("Index", intType, false, false)
			}))
		{
			Position = new Point2D(260, 60)
		};

		var consumeLoop = new NodeViewModel(new NodeData(
			Id: "consume-loop",
			Name: "Consume",
			Callable: true,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("Enter", execType, true, true),
				new SocketData("Value", intType, true, false)
			},
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(500, 60)
		};

		var markerLoop = new NodeViewModel(new NodeData(
			Id: "marker-loop",
			Name: "Marker",
			Callable: true,
			ExecInit: false,
			Inputs: new[] { new SocketData("Enter", execType, true, true) },
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(760, 60)
		};

		var startList = new NodeViewModel(new NodeData(
			Id: "start-list",
			Name: "Start",
			Callable: true,
			ExecInit: true,
			Inputs: Array.Empty<SocketData>(),
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(60, 260)
		};

		var listCreate = new NodeViewModel(new NodeData(
			Id: "list-create",
			Name: "List Create",
			Callable: false,
			ExecInit: false,
			Inputs: Array.Empty<SocketData>(),
			Outputs: new[] { new SocketData("List", listType, false, false) }))
		{
			Position = new Point2D(240, 240)
		};

		var listAddA = new NodeViewModel(new NodeData(
			Id: "list-add-a",
			Name: "List Add",
			Callable: false,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("List", listType, true, false),
				new SocketData("Value", stringType, true, false, SocketValue.FromObject("Alpha"))
			},
			Outputs: new[] { new SocketData("Result", listType, false, false) }))
		{
			Position = new Point2D(420, 220)
		};

		var listAddB = new NodeViewModel(new NodeData(
			Id: "list-add-b",
			Name: "List Add",
			Callable: false,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("List", listType, true, false),
				new SocketData("Value", stringType, true, false, SocketValue.FromObject("Beta"))
			},
			Outputs: new[] { new SocketData("Result", listType, false, false) }))
		{
			Position = new Point2D(600, 220)
		};

		var listCount = new NodeViewModel(new NodeData(
			Id: "list-count",
			Name: "List Count",
			Callable: false,
			ExecInit: false,
			Inputs: new[] { new SocketData("List", listType, true, false) },
			Outputs: new[] { new SocketData("Count", intType, false, false) }))
		{
			Position = new Point2D(780, 220)
		};

		var consumeList = new NodeViewModel(new NodeData(
			Id: "consume-list",
			Name: "Consume",
			Callable: true,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("Enter", execType, true, true),
				new SocketData("Value", intType, true, false)
			},
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(980, 220)
		};

		var stringConcat = new NodeViewModel(new NodeData(
			Id: "string-concat",
			Name: "String Concat",
			Callable: false,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("A", stringType, true, false, SocketValue.FromObject("Loop count: ")),
				new SocketData("B", stringType, true, false)
			},
			Outputs: new[] { new SocketData("Result", stringType, false, false) }))
		{
			Position = new Point2D(780, 320)
		};

		var stringLength = new NodeViewModel(new NodeData(
			Id: "string-length",
			Name: "String Length",
			Callable: false,
			ExecInit: false,
			Inputs: new[] { new SocketData("Input", stringType, true, false) },
			Outputs: new[] { new SocketData("Length", intType, false, false) }))
		{
			Position = new Point2D(980, 320)
		};

		var consumeString = new NodeViewModel(new NodeData(
			Id: "consume-string",
			Name: "Consume",
			Callable: true,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("Enter", execType, true, true),
				new SocketData("Value", intType, true, false)
			},
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(1180, 320)
		};

		var startParallel = new NodeViewModel(new NodeData(
			Id: "start-parallel",
			Name: "Start",
			Callable: true,
			ExecInit: true,
			Inputs: Array.Empty<SocketData>(),
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(60, 480)
		};

		var splitParallel = new NodeViewModel(new NodeData(
			Id: "split-parallel",
			Name: "Parallel Split",
			Callable: false,
			ExecInit: false,
			Inputs: new[] { new SocketData("Start", execType, true, true) },
			Outputs: new[]
			{
				new SocketData("PathA", execType, false, true),
				new SocketData("PathB", execType, false, true)
			}))
		{
			Position = new Point2D(260, 460)
		};

		var delayA = new NodeViewModel(new NodeData(
			Id: "delay-a",
			Name: "Delay",
			Callable: true,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("Enter", execType, true, true),
				new SocketData("DelayMs", intType, true, false, SocketValue.FromObject(400))
			},
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(520, 430)
		};

		var delayB = new NodeViewModel(new NodeData(
			Id: "delay-b",
			Name: "Delay",
			Callable: true,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("Enter", execType, true, true),
				new SocketData("DelayMs", intType, true, false, SocketValue.FromObject(700))
			},
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(520, 520)
		};

		var joinParallel = new NodeViewModel(new NodeData(
			Id: "join-parallel",
			Name: "Parallel Join",
			Callable: false,
			ExecInit: false,
			Inputs: new[]
			{
				new SocketData("PathA", execType, true, true),
				new SocketData("PathB", execType, true, true)
			},
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(760, 480)
		};

		var markerParallel = new NodeViewModel(new NodeData(
			Id: "marker-parallel",
			Name: "Marker",
			Callable: true,
			ExecInit: false,
			Inputs: new[] { new SocketData("Enter", execType, true, true) },
			Outputs: new[] { new SocketData("Exit", execType, false, true) }))
		{
			Position = new Point2D(980, 480)
		};

		EditorState.AddNode(startLoop);
		EditorState.AddNode(forLoop);
		EditorState.AddNode(consumeLoop);
		EditorState.AddNode(markerLoop);
		EditorState.AddNode(startList);
		EditorState.AddNode(listCreate);
		EditorState.AddNode(listAddA);
		EditorState.AddNode(listAddB);
		EditorState.AddNode(listCount);
		EditorState.AddNode(consumeList);
		EditorState.AddNode(stringConcat);
		EditorState.AddNode(stringLength);
		EditorState.AddNode(consumeString);
		EditorState.AddNode(startParallel);
		EditorState.AddNode(splitParallel);
		EditorState.AddNode(delayA);
		EditorState.AddNode(delayB);
		EditorState.AddNode(joinParallel);
		EditorState.AddNode(markerParallel);

		EditorState.AddConnection(new ConnectionData("start-loop", "for-loop", "Exit", "Enter", true));
		EditorState.AddConnection(new ConnectionData("for-loop", "consume-loop", "LoopPath", "Enter", true));
		EditorState.AddConnection(new ConnectionData("consume-loop", "for-loop", "Exit", "Enter", true));
		EditorState.AddConnection(new ConnectionData("for-loop", "marker-loop", "ExitPath", "Enter", true));
		EditorState.AddConnection(new ConnectionData("for-loop", "consume-loop", "Index", "Value", false));

		EditorState.AddConnection(new ConnectionData("start-list", "consume-list", "Exit", "Enter", true));
		EditorState.AddConnection(new ConnectionData("list-create", "list-add-a", "List", "List", false));
		EditorState.AddConnection(new ConnectionData("list-add-a", "list-add-b", "Result", "List", false));
		EditorState.AddConnection(new ConnectionData("list-add-b", "list-count", "Result", "List", false));
		EditorState.AddConnection(new ConnectionData("list-count", "consume-list", "Count", "Value", false));

		EditorState.AddConnection(new ConnectionData("list-count", "string-concat", "Count", "B", false));
		EditorState.AddConnection(new ConnectionData("string-concat", "string-length", "Result", "Input", false));
		EditorState.AddConnection(new ConnectionData("start-list", "consume-string", "Exit", "Enter", true));
		EditorState.AddConnection(new ConnectionData("string-length", "consume-string", "Length", "Value", false));

		EditorState.AddConnection(new ConnectionData("start-parallel", "split-parallel", "Exit", "Start", true));
		EditorState.AddConnection(new ConnectionData("split-parallel", "delay-a", "PathA", "Enter", true));
		EditorState.AddConnection(new ConnectionData("split-parallel", "delay-b", "PathB", "Enter", true));
		EditorState.AddConnection(new ConnectionData("delay-a", "join-parallel", "Exit", "PathA", true));
		EditorState.AddConnection(new ConnectionData("delay-b", "join-parallel", "Exit", "PathB", true));
		EditorState.AddConnection(new ConnectionData("join-parallel", "marker-parallel", "Exit", "Enter", true));
	}
}
