@page "/docs/custom-nodes"

<PageTitle>Custom Nodes Tutorial — NodeEditor.Net</PageTitle>

<section class="section page-top">
    <div class="section-container doc-content">
        <h1>Custom Nodes Tutorial</h1>
        <p>
            Learn how to create custom nodes and custom socket editors for NodeEditor.Net.
        </p>

        <h2>Overview</h2>
        <p>
            Custom nodes are defined as methods on classes implementing <code>INodeContext</code>,
            decorated with the <code>[Node]</code> attribute. The system supports four node types:
        </p>
        <ol>
            <li><strong>Data Nodes</strong> — Process inputs and produce outputs (no execution flow)</li>
            <li><strong>Executable Nodes</strong> — Have execution flow control</li>
            <li><strong>Entry Nodes</strong> — Start execution automatically</li>
            <li><strong>Branching Nodes</strong> — Conditional execution paths</li>
        </ol>

        <h2>Part 1: Your First Custom Node</h2>

        <h3>Step 1: Create a Node Context Class</h3>
        <pre><code>using NodeEditor.Net.Services.Registry;
using NodeEditor.Net.Services.Execution;

namespace MyApp.Nodes;

public class MathContext : INodeContext
{
    [Node("Add", category: "Math", description: "Add two numbers")]
    public void Add(double A, double B, out double Result)
    {
        Result = A + B;
    }

    [Node("Multiply", category: "Math", description: "Multiply two numbers")]
    public void Multiply(double A, double B, out double Result)
    {
        Result = A * B;
    }
}</code></pre>

        <h3>Step 2: Register the Context</h3>
        <pre><code>@@inject NodeRegistryService Registry

@@code {
    protected override void OnInitialized()
    {
        Registry.EnsureInitialized(new[] { typeof(MathContext).Assembly });
    }
}</code></pre>
        <p>Nodes appear automatically in the context menu at their configured category.</p>

        <h2>Part 2: Working with Execution Flow</h2>

        <h3>Executable Nodes</h3>
        <p>Nodes with execution flow use <code>ExecutionPath</code> parameters:</p>
        <pre><code>[Node("Print", category: "Debug", isCallable: true)]
public void Print(ExecutionPath Entry, string Message, out ExecutionPath Exit)
{
    Console.WriteLine(Message);
    Exit = new ExecutionPath();
    Exit.Signal(); // Continue execution
}</code></pre>

        <h3>Entry Nodes (Execution Initiators)</h3>
        <pre><code>[Node("Start", category: "Flow", isCallable: true, isExecutionInitiator: true)]
public void Start(out ExecutionPath Exit)
{
    Exit = new ExecutionPath();
    Exit.Signal();
}</code></pre>

        <h3>Branching Nodes</h3>
        <pre><code>[Node("Branch", category: "Flow", isCallable: true)]
public void Branch(ExecutionPath Entry, bool Condition,
                   out ExecutionPath True, out ExecutionPath False)
{
    True = new ExecutionPath();
    False = new ExecutionPath();

    if (Condition) True.Signal();
    else False.Signal();
}</code></pre>

        <h2>Part 3: Advanced Features</h2>

        <h3>Async Operations</h3>
        <p>Node methods can return <code>Task</code> for async work:</p>
        <pre><code>[Node("HTTP Get", category: "Network", isCallable: true)]
public Task HttpGet(ExecutionPath Entry, string Url,
                    out string Response, out ExecutionPath Exit)
{
    // Note: out params don't work directly with async
    // Use .GetAwaiter().GetResult() pattern
    var client = new HttpClient();
    Response = client.GetStringAsync(Url).GetAwaiter().GetResult();
    Exit = new ExecutionPath();
    Exit.Signal();
    return Task.CompletedTask;
}</code></pre>

        <h3>Cancellation Token</h3>
        <p>Add a <code>CancellationToken</code> parameter — it's automatically injected:</p>
        <pre><code>[Node("Long Operation", category: "Utils", isCallable: true)]
public void LongOp(ExecutionPath Entry, int DurationMs,
                   CancellationToken token, out ExecutionPath Exit)
{
    Task.Delay(DurationMs, token).GetAwaiter().GetResult();
    Exit = new ExecutionPath();
    Exit.Signal();
}</code></pre>

        <h2>Part 4: Socket Editors (Attribute-Based)</h2>
        <p>Use <code>[SocketEditor]</code> to control inline editing:</p>
        <pre><code>[Node("Config Node", category: "Settings", isCallable: true)]
public void Config(
    ExecutionPath Entry,
    [SocketEditor(SocketEditorKind.Text, Label = "Name")] string Name,
    [SocketEditor(SocketEditorKind.NumberUpDown, Min = 0, Max = 100)] int Value,
    [SocketEditor(SocketEditorKind.Dropdown, Options = "Low,Medium,High")] string Priority,
    [SocketEditor(SocketEditorKind.Bool)] bool Enabled,
    out ExecutionPath Exit)
{
    // ...
    Exit = new ExecutionPath();
    Exit.Signal();
}</code></pre>

        <h2>Part 5: Custom Socket Editors (Plugin)</h2>
        <p>For fully custom Blazor UI, implement <code>INodeCustomEditor</code>:</p>
        <pre><code>public sealed class ImageEditorDefinition : INodeCustomEditor
{
    public bool CanEdit(SocketData socket)
    {
        if (socket.IsExecution || !socket.IsInput) return false;
        return socket.Name.Equals("ImagePath", StringComparison.Ordinal);
    }

    public RenderFragment Render(SocketEditorContext context)
    {
        return builder =&gt;
        {
            builder.OpenComponent&lt;ImageEditor&gt;(0);
            builder.AddAttribute(1, "Context", context);
            builder.CloseComponent();
        };
    }
}</code></pre>
        <p>Custom editors are <strong>auto-discovered</strong> from the plugin assembly — no manual registration needed.</p>

        <h2>Part 6: Creating a Plugin</h2>
        <ol>
            <li>Copy <code>NodeEditor.Plugins.Template</code> to a new folder</li>
            <li>Implement <code>INodePlugin</code>:
                <pre><code>public sealed class MyPlugin : INodePlugin
{
    public string Name =&gt; "My Plugin";
    public string Id =&gt; "com.example.myplugin";

    public void Register(INodeRegistryService registry)
    {
        registry.RegisterFromAssembly(typeof(MyPlugin).Assembly);
    }
}</code></pre>
            </li>
            <li>Add your <code>INodeContext</code> classes with <code>[Node]</code> methods</li>
            <li>Create <code>plugin.json</code> manifest</li>
            <li>Build and publish: <code>./publish-plugin.ps1 -PluginProject path/to/MyPlugin.csproj</code></li>
        </ol>

        <h2>Best Practices</h2>
        <ul>
            <li>Keep node methods focused — one operation per node</li>
            <li>Use descriptive names and categories for easy discovery</li>
            <li>Use <code>out</code> parameters for all outputs</li>
            <li>Always <code>Signal()</code> at least one <code>ExecutionPath</code> output</li>
            <li><code>INodeContext</code> implementations must have parameterless constructors</li>
            <li>Handle exceptions gracefully — failed nodes show error state in the UI</li>
            <li>Add <code>[SocketEditor]</code> hints for better UX on input sockets</li>
        </ul>

        <div class="doc-nav">
            <a href="documentation">← Back to Documentation</a>
        </div>
    </div>
</section>
