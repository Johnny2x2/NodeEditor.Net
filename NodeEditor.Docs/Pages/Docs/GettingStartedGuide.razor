@page "/docs/getting-started"

<PageTitle>Getting Started — NodeEditor.Net</PageTitle>

<section class="section page-top">
    <div class="section-container doc-content">
        <h1>Getting Started with NodeEditor.Net</h1>
        <p>
            This guide walks you through setting up NodeEditor.Net, creating your first node graph, and running it.
        </p>

        <h2>Prerequisites</h2>
        <ul>
            <li><a href="https://dotnet.microsoft.com/download/dotnet/10.0">.NET 10 SDK</a></li>
            <li>A code editor (Visual Studio, VS Code, Rider, etc.)</li>
        </ul>

        <h2>Step 1: Create a New Blazor Project</h2>
        <pre><code>dotnet new blazor -n MyNodeEditor --interactivity Server
cd MyNodeEditor</code></pre>

        <h2>Step 2: Add NodeEditor.Net References</h2>
        <p>Add a project reference to <code>NodeEditor.Blazor</code> (which transitively includes <code>NodeEditor.Net</code>):</p>
        <pre><code>&lt;!-- MyNodeEditor.csproj --&gt;
&lt;ItemGroup&gt;
  &lt;ProjectReference Include="../NodeEditor.Blazor/NodeEditor.Blazor.csproj" /&gt;
&lt;/ItemGroup&gt;</code></pre>

        <h2>Step 3: Register Services</h2>
        <p>In your <code>Program.cs</code>, register all node editor services with a single call:</p>
        <pre><code>using NodeEditor.Blazor.Services;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

// Register all node editor services
builder.Services.AddNodeEditor();

var app = builder.Build();
app.UseStaticFiles();
app.UseAntiforgery();
app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode();
app.Run();</code></pre>

        <h3>Services Registered by AddNodeEditor()</h3>
        <table class="docs-table">
            <thead><tr><th>Service</th><th>Lifetime</th><th>Purpose</th></tr></thead>
            <tbody>
                <tr><td><code>NodeEditorState</code></td><td>Scoped</td><td>Central state management with events</td></tr>
                <tr><td><code>NodeExecutionService</code></td><td>Scoped</td><td>Executes node graphs</td></tr>
                <tr><td><code>GraphSerializer</code></td><td>Scoped</td><td>JSON save/load</td></tr>
                <tr><td><code>NodeRegistryService</code></td><td>Singleton</td><td>Manages available node definitions</td></tr>
                <tr><td><code>PluginLoader</code></td><td>Singleton</td><td>Loads plugins from disk</td></tr>
                <tr><td><code>SocketTypeResolver</code></td><td>Singleton</td><td>Maps type names to .NET types</td></tr>
                <tr><td><code>ConnectionValidator</code></td><td>Scoped</td><td>Validates socket connections</td></tr>
                <tr><td><code>INodeEditorLogger</code></td><td>Singleton</td><td>Channel-based logging</td></tr>
            </tbody>
        </table>

        <h2>Step 4: Add the Node Editor Canvas</h2>
        <pre><code>@@page "/editor"
@@using NodeEditor.Blazor.Components
@@using NodeEditor.Net.Services
@@using NodeEditor.Net.Services.Registry
@@inject NodeEditorState EditorState
@@inject INodeRegistryService Registry

&lt;PageTitle&gt;Node Editor&lt;/PageTitle&gt;

&lt;div style="width: 100%; height: 100vh; position: relative;"&gt;
    &lt;NodeEditorCanvas State="@@EditorState" /&gt;
&lt;/div&gt;

@@code {
    protected override void OnInitialized()
    {
        Registry.RegisterFromAssembly(typeof(AddNode).Assembly);
    }
}</code></pre>

        <h2>Step 5: Define Your First Nodes</h2>
        <p>Create node classes by subclassing <code>NodeBase</code>. Each node overrides <code>Configure</code> (to declare metadata and sockets) and <code>ExecuteAsync</code> (to run logic):</p>
        <pre><code class="language-csharp">using NodeEditor.Net.Services.Execution;

namespace MyNodeEditor;

// A data node — computes a value from inputs (no execution flow sockets)
public sealed class AddNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("Add").Category("Math")
            .Description("Adds two numbers.")
            .Input&lt;double&gt;("A", 0.0)
            .Input&lt;double&gt;("B", 0.0)
            .Output&lt;double&gt;("Result");
    }

    public override Task ExecuteAsync(INodeExecutionContext context, CancellationToken ct)
    {
        var a = context.GetInput&lt;double&gt;("A");
        var b = context.GetInput&lt;double&gt;("B");
        context.SetOutput("Result", a + b);
        return Task.CompletedTask;
    }
}

// A callable node — has execution flow sockets (Enter/Exit)
public sealed class PrintNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("Print").Category("Debug")
            .Description("Prints a message to the debug output.")
            .Callable()
            .Input&lt;string&gt;("Message", "");
    }

    public override async Task ExecuteAsync(INodeExecutionContext context, CancellationToken ct)
    {
        var message = context.GetInput&lt;string&gt;("Message");
        context.EmitFeedback(message, ExecutionFeedbackType.DebugPrint);
        await context.TriggerAsync("Exit");
    }
}

// An execution initiator — starts the execution chain
public sealed class MyStartNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("My Start").Category("Flow")
            .Description("Entry point for execution.")
            .ExecutionInitiator();
    }

    public override async Task ExecuteAsync(INodeExecutionContext context, CancellationToken ct)
    {
        await context.TriggerAsync("Exit");
    }
}</code></pre>

        <h2>Step 6: Run Your App</h2>
        <pre><code>dotnet run</code></pre>
        <p>Open the browser and navigate to <code>/editor</code>. You should see:</p>
        <ul>
            <li>A dark canvas that you can <strong>pan</strong> (middle-click drag) and <strong>zoom</strong> (scroll wheel)</li>
            <li><strong>Right-click</strong> to open the context menu and add nodes</li>
            <li><strong>Drag from a socket</strong> to create connections between nodes</li>
            <li><strong>Click a node</strong> to select it; press <strong>Delete</strong> to remove it</li>
        </ul>

        <h2>Understanding Node Types</h2>

        <h3>Data Nodes (no execution sockets)</h3>
        <p>Compute outputs from inputs. No execution flow sockets. Evaluate lazily when outputs are needed. Omit <code>Callable()</code> / <code>ExecutionInitiator()</code> in the builder.</p>
        <pre><code class="language-csharp">public sealed class MultiplyNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("Multiply").Category("Math")
            .Input&lt;double&gt;("A", 0.0)
            .Input&lt;double&gt;("B", 0.0)
            .Output&lt;double&gt;("Result");
    }

    public override Task ExecuteAsync(INodeExecutionContext context, CancellationToken ct)
    {
        context.SetOutput("Result", context.GetInput&lt;double&gt;("A") * context.GetInput&lt;double&gt;("B"));
        return Task.CompletedTask;
    }
}</code></pre>

        <h3>Callable Nodes</h3>
        <p>Participate in execution flow. Call <code>Callable()</code> on the builder to add <code>Enter</code> and <code>Exit</code> execution sockets automatically. Trigger the next node with <code>context.TriggerAsync("Exit")</code>.</p>

        <h3>Execution Initiators</h3>
        <p>Start an execution chain. Call <code>ExecutionInitiator()</code> — adds an <code>Exit</code> execution output but no execution input.</p>

        <h3>Branching Nodes</h3>
        <p>Create conditional execution by using named execution inputs/outputs and triggering different paths:</p>
        <pre><code class="language-csharp">public sealed class BranchNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("Branch").Category("Conditions")
            .Description("Branch on a boolean condition.")
            .ExecutionInput("Start")
            .Input&lt;bool&gt;("Cond")
            .ExecutionOutput("True")
            .ExecutionOutput("False");
    }

    public override async Task ExecuteAsync(INodeExecutionContext context, CancellationToken ct)
    {
        var cond = context.GetInput&lt;bool&gt;("Cond");
        await context.TriggerAsync(cond ? "True" : "False");
    }
}</code></pre>

        <h2>Canvas Interactions</h2>
        <table class="docs-table">
            <thead><tr><th>Action</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><strong>Right-click</strong> on canvas</td><td>Open context menu to add nodes</td></tr>
                <tr><td><strong>Left-click + drag</strong> on canvas</td><td>Box selection</td></tr>
                <tr><td><strong>Left-click + drag</strong> on a node</td><td>Move node (or all selected nodes)</td></tr>
                <tr><td><strong>Left-click + drag</strong> from a socket</td><td>Create a connection</td></tr>
                <tr><td><strong>Middle-click + drag</strong></td><td>Pan the canvas</td></tr>
                <tr><td><strong>Scroll wheel</strong></td><td>Zoom in/out</td></tr>
                <tr><td><strong>Delete / Backspace</strong></td><td>Delete selected nodes</td></tr>
                <tr><td><strong>Ctrl+A</strong></td><td>Select all nodes</td></tr>
                <tr><td><strong>Escape</strong></td><td>Cancel current operation</td></tr>
            </tbody>
        </table>

        <h2>Saving and Loading Graphs</h2>
        <pre><code>@@inject GraphSerializer Serializer

// Save
var dto = Serializer.Export(EditorState);
var json = Serializer.Serialize(dto);
File.WriteAllText("my-graph.json", json);

// Load
var json = File.ReadAllText("my-graph.json");
var dto = Serializer.Deserialize(json);
var result = Serializer.Import(EditorState, dto);</code></pre>

        <h2>Using Socket Editors</h2>
        <p>Control how socket values are edited by passing a <code>SocketEditorHint</code> to the builder's <code>Input</code> call:</p>
        <pre><code class="language-csharp">using NodeEditor.Net.Models;
using NodeEditor.Net.Services.Execution;

public sealed class ImageLoaderNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("Image Loader").Category("Media")
            .Description("Load an image file.")
            .Callable()
            .Input&lt;string&gt;("ImagePath", "",
                editorHint: new SocketEditorHint(SocketEditorKind.Image, Label: "Image Path"))
            .Input&lt;string&gt;("Format", "PNG",
                editorHint: new SocketEditorHint(SocketEditorKind.Dropdown, Options: "PNG,JPEG,BMP"))
            .Input&lt;int&gt;("Quality", 80,
                editorHint: new SocketEditorHint(SocketEditorKind.NumberUpDown, Min: 0, Max: 100, Step: 1));
    }

    public override async Task ExecuteAsync(INodeExecutionContext context, CancellationToken ct)
    {
        // ...
        await context.TriggerAsync("Exit");
    }
}</code></pre>
        <p>Available editor kinds: <code>Text</code>, <code>Number</code>, <code>Bool</code>, <code>Dropdown</code>, <code>Button</code>, <code>Image</code>, <code>NumberUpDown</code>, <code>TextArea</code>, <code>Custom</code>.</p>

        <h2>Next Steps</h2>
        <ul>
            <li><a href="docs/features-overview">Features Overview</a> — Learn about all capabilities</li>
            <li><a href="docs/custom-nodes">Custom Nodes Tutorial</a> — Advanced node creation patterns</li>
            <li><a href="docs/plugin-sdk">Plugin SDK</a> — Package your nodes as a reusable plugin</li>
            <li><a href="docs/execution-engine">Execution Engine</a> — Understand graph planning and execution</li>
            <li><a href="docs/mcp-integration">MCP Integration</a> — Let AI assistants build graphs</li>
        </ul>

        <div class="doc-nav">
            <a href="documentation">← Back to Documentation</a>
        </div>
    </div>
</section>
