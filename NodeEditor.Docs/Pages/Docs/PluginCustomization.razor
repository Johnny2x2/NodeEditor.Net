@page "/docs/plugin-customization"

<PageTitle>Plugin Customization — NodeEditor.Net</PageTitle>

<section class="section page-top">
    <div class="section-container doc-content">
        <h1>Plugin Customization Guide</h1>
        <p>
            This guide describes everything a plugin can currently customize in NodeEditor.Net.
        </p>

        <h2>1. Custom Nodes</h2>
        <p>
            Plugins define node logic by subclassing <code>NodeBase</code>, overriding
            <code>Configure(INodeBuilder)</code> for metadata/sockets and
            <code>ExecuteAsync(INodeExecutionContext, CancellationToken)</code> for logic.
        </p>

        <h3>Builder API</h3>
        <table class="docs-table">
            <thead><tr><th>Method</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>Name(string)</code></td><td>Display name in the editor</td></tr>
                <tr><td><code>Category(string)</code></td><td>Grouping category</td></tr>
                <tr><td><code>Description(string)</code></td><td>Tooltip / description text</td></tr>
                <tr><td><code>Input&lt;T&gt;(name, default?, editorHint?)</code></td><td>Add an input socket</td></tr>
                <tr><td><code>Output&lt;T&gt;(name)</code></td><td>Add an output socket</td></tr>
                <tr><td><code>Callable()</code></td><td>Add Enter/Exit execution sockets</td></tr>
                <tr><td><code>ExecutionInitiator()</code></td><td>Add Exit only (entry point)</td></tr>
                <tr><td><code>ExecutionInput(name)</code></td><td>Named execution input</td></tr>
                <tr><td><code>ExecutionOutput(name)</code></td><td>Named execution output</td></tr>
            </tbody>
        </table>

        <h3>Example</h3>
        <pre><code>public sealed class EchoStringNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("Echo String")
               .Category("Utilities")
               .Description("Echoes a string")
               .Input&lt;string&gt;("Input", "")
               .Output&lt;string&gt;("Output");
    }

    public override Task ExecuteAsync(
        INodeExecutionContext context, CancellationToken ct)
    {
        context.SetOutput("Output", context.GetInput&lt;string&gt;("Input"));
        return Task.CompletedTask;
    }
}

public sealed class StartNode : NodeBase
{
    public override void Configure(INodeBuilder builder)
    {
        builder.Name("Start").Category("Flow")
               .ExecutionInitiator();
    }

    public override async Task ExecuteAsync(
        INodeExecutionContext context, CancellationToken ct)
    {
        await context.TriggerAsync("Exit");
    }
}</code></pre>

        <h2>2. Node Registration</h2>
        <p>In the <code>Register(INodeRegistryService registry)</code> method, plugins register their nodes:</p>
        <ul>
            <li><strong>Auto-discovery:</strong> <code>registry.RegisterFromAssembly(typeof(MyPlugin).Assembly)</code> scans for <code>NodeBase</code> subclasses</li>
            <li><strong>Manual:</strong> <code>registry.RegisterDefinitions(...)</code> for fine-grained control</li>
        </ul>
        <p>The registry also supports <code>RemoveDefinitions</code>, <code>RemoveDefinitionsFromAssembly</code>, and <code>GetCatalog()</code>.</p>

        <h2>3. Dependency Injection</h2>
        <p>Plugins can register their own services:</p>
        <pre><code>public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&lt;IMyService, MyService&gt;();
}</code></pre>
        <p>
            These services are scoped per-plugin through <code>IPluginServiceRegistry</code> and available
            during <code>OnInitializeAsync</code> via the provided <code>IServiceProvider</code>.
        </p>

        <h2>4. Custom Socket Editors</h2>
        <p>Plugins can provide custom Blazor UI for editing socket values by implementing <code>INodeCustomEditor</code>:</p>
        <pre><code>public interface INodeCustomEditor
{
    bool CanEdit(SocketData socket);
    RenderFragment Render(SocketEditorContext context);
}</code></pre>
        <ul>
            <li><strong><code>CanEdit</code></strong> — Inspects the socket to decide if this editor handles it</li>
            <li><strong><code>Render</code></strong> — Returns a Blazor <code>RenderFragment</code> for the custom editor UI</li>
        </ul>
        <p>Custom editors are <strong>auto-discovered</strong> from the plugin assembly — no manual registration needed.</p>

        <h2>5. Custom Log Channels</h2>
        <p>Plugins implementing <code>ILogChannelAware</code> can register named log channels:</p>
        <pre><code>public sealed class MyPlugin : INodePlugin, ILogChannelAware
{
    public void RegisterChannels(ILogChannelRegistry registry)
    {
        registry.RegisterChannel("My Plugin Output", pluginId: Id);
    }
}</code></pre>

        <h2>6. Event Subscriptions</h2>
        <p>Plugins can subscribe to editor events through <code>IPluginEventBus</code>:</p>
        <table class="docs-table">
            <thead><tr><th>Event</th><th>Subscribe Method</th></tr></thead>
            <tbody>
                <tr><td>Node added</td><td><code>SubscribeNodeAdded</code></td></tr>
                <tr><td>Node removed</td><td><code>SubscribeNodeRemoved</code></td></tr>
                <tr><td>Connection added</td><td><code>SubscribeConnectionAdded</code></td></tr>
                <tr><td>Connection removed</td><td><code>SubscribeConnectionRemoved</code></td></tr>
                <tr><td>Selection changed</td><td><code>SubscribeSelectionChanged</code></td></tr>
                <tr><td>Viewport changed</td><td><code>SubscribeViewportChanged</code></td></tr>
                <tr><td>Zoom changed</td><td><code>SubscribeZoomChanged</code></td></tr>
                <tr><td>Socket values changed</td><td><code>SubscribeSocketValuesChanged</code></td></tr>
                <tr><td>Node execution state</td><td><code>SubscribeNodeExecutionStateChanged</code></td></tr>
                <tr><td>Log message</td><td><code>SubscribeLogMessage</code></td></tr>
            </tbody>
        </table>
        <p>All <code>Subscribe*</code> methods return <code>IDisposable</code> for clean unsubscription.</p>

        <h2>7. Lifecycle Hooks</h2>
        <table class="docs-table">
            <thead><tr><th>Hook</th><th>When It Fires</th></tr></thead>
            <tbody>
                <tr><td><code>Register</code></td><td>During plugin loading — register nodes here</td></tr>
                <tr><td><code>ConfigureServices</code></td><td>After registration — add DI services</td></tr>
                <tr><td><code>OnLoadAsync</code></td><td>After assembly is loaded</td></tr>
                <tr><td><code>OnInitializeAsync</code></td><td>After DI container is built; full <code>IServiceProvider</code> available</td></tr>
                <tr><td><code>OnUnloadAsync</code></td><td>Before plugin is unloaded</td></tr>
                <tr><td><code>OnError</code></td><td>On unhandled plugin exception</td></tr>
                <tr><td><code>Unload</code></td><td>Synchronous final cleanup</td></tr>
            </tbody>
        </table>

        <h2>8. Plugin Manifest</h2>
        <pre><code>{
    "Id": "com.nodeeditormax.myplugin",
    "Name": "My Plugin",
    "Version": "1.0.0",
    "MinApiVersion": "1.0.0",
    "EntryAssembly": "MyPlugin.dll",
    "Category": "Utilities"
}</code></pre>
        <table class="docs-table">
            <thead><tr><th>Field</th><th>Required</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>Id</code></td><td>Yes</td><td>Unique plugin identifier (reverse-domain convention)</td></tr>
                <tr><td><code>Name</code></td><td>Yes</td><td>Human-readable display name</td></tr>
                <tr><td><code>Version</code></td><td>Yes</td><td>Plugin version (semver)</td></tr>
                <tr><td><code>MinApiVersion</code></td><td>Yes</td><td>Minimum host API version required</td></tr>
                <tr><td><code>EntryAssembly</code></td><td>No</td><td>DLL filename containing the <code>INodePlugin</code></td></tr>
                <tr><td><code>Category</code></td><td>No</td><td>Plugin category for marketplace/organization</td></tr>
            </tbody>
        </table>

        <h2>What Plugins Cannot Customize</h2>
        <ul>
            <li>Canvas themes or visual styling</li>
            <li>Toolbar items or menus</li>
            <li>Context menu entries</li>
            <li>Connection rendering rules or styles</li>
            <li>Keyboard shortcuts</li>
            <li>Panel/dock layout</li>
        </ul>

        <div class="doc-nav">
            <a href="documentation">← Back to Documentation</a>
        </div>
    </div>
</section>
